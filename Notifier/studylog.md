# 알림 클래스 학습 로그: 설계에 대해 고민하다
## 📖 개요
    DI(의존성 주입)을 구현하기 위한 인터페이스와 클래스 구조를 작성하며, 결합도 및 SOLID와 같은 원칙들을 생각해보기 시작했습니다.
## 🔥 핵심 기능
- `Inotifier` 인터페이스: 순수 가상 함수로 `EmailNotifier`와 `TestNotifier`가 오직 의존할 인터페이스입니다.
- `EmailNotifier`, `TestNotifier` 파생 클래스: `Inotifier`를 구현하고, `OrderService` 객체에 의존성이 주입될 클래스입니다.
- `OrderService` 클래스: 의존성을 주입받아, 주문을 처리하는 구조의 객체입니다.

## 🔎 탐구 과정
### 1. 묘한 시작, vfptr와 vtable
- 이 작은 프로젝트를 시작하기 전, 저는 `vfptr`와 `vtable`에 대해 익히고 있었습니다.
- 상속받거나 가상 함수를 가지는 객체만 `vfptr`를 가지고, `vtable`에는 가상 함수와 `override` 된 함수만이 인덱싱 된다는 것을 알았습니다.
### 2. 싱글톤 패턴에 대해 알게 되다
- 이러한 과정에서 싱글톤 패턴과 구조에 대해 알게 되었습니다.
- 동시에, 그것이 안티 패턴으로 여겨질 때도 있다는 것 또한 알게 되었습니다.
### 3. DI 패턴, SOLID에 대한 생각을 하기 시작하다
- 싱글톤 패턴의 대안으로 `DI`(의존성 주입 패턴)에 대한 것을 알게 되었습니다.
- 동시에 `OCP`, `DIP` 등의 SOLID(이 때는 정확한 원칙을 몰랐지만)에 대한 것을 알게 되고 이 Inotifier 코드를 작성하게 되었습니다.
### 4. 의존성 주입과 결합도, SOLID
- 객체를 전달하는 개념에 생소했던 저는 꽤나 구현에 시간이 걸렸습니다.
- 그와 동시에, 결합도, c++의 원칙들에 대한 것을 이해해 나갔습니다.
```c++
// 생성자 주입 DI 패턴, 결합도를 이해하기 시작하다
OrderService(Inotifier& notifier) : notifier(notifier){}
```
### 5. OCP의 미학에 알게 되다
- 이윽고, `TestNotifier`를 작성하고 객체지향의 미학에 대해 알게 되었습니다.
- 짧고 간단한 코드였지만, 여태껏 코드를 작성하며 가장 많은 것을 알게 된 것 같았습니다.