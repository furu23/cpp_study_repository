# 챗 시스템 클래스 학습 로그: 끝없는 고민
## 🔎 학습과 탐구, 고민 과정
*코드의 구성과 내용은 readme.md를 참고해주세요.*
### 1. 시작, 람다를 배우자!
시작은 람다를 익히기 위한 가벼운 학습이 될 예정이었습니다. 저는 자연어 생성 AI 모델과 대화하며, 람다를 익히고 예제 문제를 만들어서 람다에 대한 것들을 가볍게 익혀보고 있었습니다.
### 2. 이것저것 해보자.
그렇게 첫 번째 코드를 작성하며, 저는 이것저것 많은 것들을 넣기 시작했습니다. 다양한 범위의 학습을 하길 바랬으며 또 이용해보고 싶었습니다. 사용해본 것들은 처음에는 다음과 같았습니다.
- std::function: 람다를 저장해서 관리해보자
- std::unique_ptr: 저장하려니까, 포인터로 생명주기를 관리해서 보관하자
- 이동 시멘틱스: unique_ptr과 vector 관리에 더불어, 객체도 이용해보자.
- ChatUser 클래스: 너무 길어지는 main. SOLID 원칙을 생각하며 분리해보자.
### 3. SOLID, 생각해버리다.
SOLID를 고려하는 것까지는 훌륭한 생각이었습니다. 그리고 AI와 대화하며, shared_ptr과 weak_ptr을 사용하기 시작하면서 저는 SOLID와 다형성, 캡슐화, 상속성 등의 객체지형 원칙의 늪에 빠져버렸습니다.
- 람다와 unique_ptr로 인한 생명 주기 위험성 관리를 위한, shared_ptr 사용, ChatUser 관리 시작.
- 동시에 템플릿을 통해 다양한 타입을 쓸 수 있도록 다형성을 지원하기 시작.
- 포인터 선언과 객체 선언 및 관리가 main에 무척 덕지덕지 붙기 시작
- SRP(단일 책임 원칙) 고려 시작
### 4. SOLID에 대한 끝없는 고민, ChatSystem 객체 등장.
더러워진 main이 점점 묘하게 거슬려 왔습니다. SOLID를 완전히 알고 있는 것은 아니지만, 이것이 위배된다는 사실이 직관적으로 알게 되었습니다. SRP에 대한 위배인 것을 깨달은 저는 즉시 다른 고민을 하기 시작했습니다.
- SRP를 위해 main의 책임을 줄이고자 함, main에서 다양한 객체 선언을 없애버리고, 극한의 추상화를 위해 ChatSystem 객체가 모든 것을 맡도록 함
- 또다른 문제 등장! ChatSystem 객체와 ChatUser 객체가 사실상 '결합'하게 됨. SOLID의 딜레마에 부딪힘.
- 동시에 템플릿으로 떡칠된 코드, 다형성을 포기할 수 없었기에(학습용 목적) 수많은 에러를 경험함
### 5. 결합도 해결을 위해 또다른 추상화, 인터페이스 만들기.
지금껏 SOLID를 지키기 위해 ChatSystem 객체까지 만든 판에, 이제와서 ChatSystem 객체와 ChatUser 객체의 거의 완전한 결합을 허락하는 것은 말이 안되는 일이었습니다. 검색과 AI의 도움을 통한 해결방법을 모색한 결과, Event와 ChatUser에 대한 추가적인 추상화를 진행하기로 했습니다.
- 추가적인 추상화로 DIP, OCP, SRP 등을 모두 기여할 수 있는 인터페이스 추가 작성, IEvent, IUser 객체가 작성되며 추가적인 복잡도.
- 점점 AI 모델도 오류를 잘 잡지 못하게 되어 직접 디버깅하는 시간이 점점 늘어나기 시작
- 그렇게 마지막 즈음 결코 바꿀 수 없는 ChatUser 발견.
### 6. 추상 팩토리까지 작성, 직접 생각하고 제안하다.
그렇게 열심히 코드를 작성해 나간 저는 '객체 선언'을 위해 반드시 ChatUser를 작성해야 하는, 혹은 복잡도를 희생해야 하는 선택을 하게 되었습니다. 그리고 저는 여기까지 끝없이 고민을 이어나가며 작성한 결과. 스스로 몇 개의 시나리오를 생각하고 추상 팩토리를 작성하는 결론에 이르렀습니다. 복잡도보다, 추상화를 끝마치는 것이 이 코드를 위해 '나은' 것이라고 직접 생각할 수 있게 되었습니다.
- 추상 팩토리 인터페이스 IUserFactory, 구체화한 ChatFactory 작성
- 이를 통해 ChatSystem과 ChatUser와의 결합을 느슨하게 만들었음
- 새 User Class를 넣으려면, 새 Factory를 상속 및 작성하면 되는 OCP에 부합하는 SOLID를 고려한 설계
### 7. 기묘한 회귀, 컴포지션 루트와 SRP에 대한 새로운 이해
이 결과 묘하게도, 저는 또다시 main에서 Event 객체와 Factory 객체를 만들게 되었습니다. 당초 목적했던, ChatSystem에서 전부 담당화는 추상화는 아니었으나. 이전의 main과는 다른 좋은 설계라는 생각을 할 수 있었습니다. 이 main은 컴포지션 루트로서, SRP에 부합하는 '조립 및 조합'의 책임을 가지는 것으로 볼 수 있었습니다.
- 주석을 달며 코드들을 다시 돌아보고, AI와 리뷰하며 에러와 고칠 점을 고쳐나감
- 헤더 파일로 각각의 코드들을 나누어 봄
### 8. 마치며
그렇게 저는 만족스러운 코드를 얻을 수 있었습니다. 그보다 좋은 것은, 높은 수준의 추상화를 여러가지 기능을 더하고, 템플릿이라는 다형성 아래에서 작성한 것이었습니다. 그것보다도 더욱 좋은 것은, 제 스스로가 SOLID와 객체지향 특성을 고려하여 판단할 수 있게 된 것이었습니다.   
이것은 분명 제게는 어려운 도전이었으나, 저는 분명 그 가치가 있었다고 믿습니다.
